<template>
  <div>
    <!-- <h3>JavaScript面向对象编程</h3> -->
    <h4>原始模式</h4>
    <p>
      把属性和方法封装成对象，这个方法的缺点：1、如果实例多，写起来麻烦。2、实例和原型之间没有联系
    </p>
    <p>
      改进，写成一个函数，但是实例之间没有内在的联系，不能反映出它们是同一个原型的实例。
    </p>
    <el-divider/>
    <h4>构造函数模式</h4>
    <p>
      构造函数就是在函数内部使用this变量，对构造函数使用new运算符就可以生成新的实例，并用this绑定在实例对象上。
    </p>
    <p>
      每一个实例会自动包含一个constructor属性，指向它们得构造函数。
    </p>
    <p>
      还可以用instanceof运算符验证实例和原型之间的关系。
    </p>
    <el-divider/>
    <el-backtop/>
    <h4>构造函数模式的问题</h4>
    <p>
      构造函数模式的问题就是存在浪费内存的问题。
    </p>
    <p>对于不变的函数和方法，每一次创建新实例，都要为重复的内容，占用内存。</p>
    <el-divider/>
    <h4>prototype模式</h4>
    <p>
      每一个构造函数都有一个prototype属性，指向另一个对象，这个对象所有的属性和方法，都会被构造函数的实例继承。
    </p>
    <p>
      将不变的属性和方法，定义在prototype对象上，就可以提高运行效率。
    </p>
    <el-divider/>
    <h4>prototype模式的验证方法</h4>
    <p>
      isPrototypeOf()；用来判断某个prototype对象和实例之间的关系。
    </p>
    <p>
      hasOwnProperty()：用来判断对象的属性是本地属性还是继承prototype的属性
    </p>
    <p>
      in运算符，用来判断对象是否有某个属性，不管本地不本地的。也可以用来遍历对象的属性。
    </p>
  </div>
</template>
<script>
export default {
  name: 'JsOo'
}
</script>
